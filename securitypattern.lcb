/*
    Copyright Â© 2019-2021 FerrusLogic. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to
    do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


widget community.ferruslogic.widget.securitypattern

    use com.livecode.canvas
    use com.livecode.widget
    use com.livecode.library.widgetutils
    use com.livecode.engine
    use com.livecode.math
    use com.livecode.type
    use com.livecode.system


    metadata title is "Security Pattern"
    metadata author is "FerrusLogic"
    metadata version is "0.0.1"
    metadata svgicon is "M12 16C13.1 16 14 16.9 14 18S13.1 20 12 20 10 19.1 10 18 10.9 16 12 16M12 10C13.1 10 14 10.9 14 12S13.1 14 12 14 10 13.1 10 12 10.9 10 12 10M12 4C13.1 4 14 4.9 14 6S13.1 8 12 8 10 7.1 10 6 10.9 4 12 4M6 16C7.1 16 8 16.9 8 18S7.1 20 6 20 4 19.1 4 18 4.9 16 6 16M6 10C7.1 10 8 10.9 8 12S7.1 14 6 14 4 13.1 4 12 4.9 10 6 10M6 4C7.1 4 8 4.9 8 6S7.1 8 6 8 4 7.1 4 6 4.9 4 6 4M18 16C19.1 16 20 16.9 20 18S19.1 20 18 20 16 19.1 16 18 16.9 16 18 16M18 10C19.1 10 20 10.9 20 12S19.1 14 18 14 16 13.1 16 12 16.9 10 18 10M18 4C19.1 4 20 4.9 20 6S19.1 8 18 8 16 7.1 16 6 16.9 4 18 4Z"
    metadata preferredSize  is "200,200"


    private variable mWorkRect as Rectangle


    private variable mRecalculate as Boolean
    private variable mAnimated as Boolean
    private variable mHeight as Real
    private variable mWidth as Real
    private variable mBackgroundOpacity as Real
    private variable mCirclePathList as List
    private variable mRectList as List
    private variable mBackColor as Color
    private variable mNodePathList as List
    private variable mCircleOver as Integer
    private variable mLastNode as Integer
    private variable mCurrentNode as Integer
    private variable mHiliteColor as Color

    metadata backgroundColor.default is "244,244,244"
    metadata backgroundColor.editor	is "com.livecode.pi.color"
    metadata backgroundColor.label is "background color"

    property backgroundOpacity 		get getBackgroundOpacity		set setBackgroundOpacity
    metadata backgroundOpacity.default is "100"
    metadata backgroundOpacity.editor	is "com.livecode.pi.number"
    metadata backgroundOpacity.label is "Background Opacity"


    private handler setBackgroundOpacity(in pBackgroundOpacity as Real)

        if pBackgroundOpacity is a number then
            if pBackgroundOpacity >= 0 and pBackgroundOpacity <= 100 then
                put pBackgroundOpacity / 100 into mBackgroundOpacity

            else if pBackgroundOpacity < 0 then
                put 0 into mBackgroundOpacity

            else if pBackgroundOpacity > 100 then
                put 1 into mBackgroundOpacity
            end if

        else
            put 0 into mBackgroundOpacity

        end if

        redraw all
    end handler


    private handler getBackgroundOpacity() returns Real
        return mBackgroundOpacity * 100
    end handler


    private variable mShowPattern as Boolean
    property showPattern 		get mShowPattern		set setShowPattern
    metadata showPattern.default is "true"
    metadata showPattern.editor	is "com.livecode.pi.boolean"
    metadata showPattern.label is "Show Pattern"

    private handler setShowPattern(in pValue as Boolean)
        if pValue is a boolean then
          put pValue into mShowPattern
        else
          put false into mShowPattern
        end if
    end handler


    private variable mShowNodesArea as Boolean
    property showNodesArea 		get mShowNodesArea		set setShowNodesArea
    metadata showNodesArea.default is "true"
    metadata showNodesArea.editor	is "com.livecode.pi.boolean"
    metadata showNodesArea.label is "Show Nodes Area"

    private handler setShowNodesArea(in pValue as Boolean)
        if pValue is a boolean then
          put pValue into mShowNodesArea

        else
          put false into mShowNodesArea

        end if

        redraw all
    end handler



    private variable mRoundRadius as Real
    property RoundedRadius 	get mRoundRadius set setRoundRadius
    metadata RoundedRadius.default is "8"
    metadata RoundedRadius.editor	is "com.livecode.pi.number"
    metadata RoundedRadius.label is "RoundedRadius"

    private handler setRoundRadius(in pValue as Real)

        if pValue is a number and pValue > 0 then
          put pValue into mRoundRadius

        else
          put 0 into mRoundRadius

        end if

        redraw all
    end handler


    metadata foregroundColor.default is "105,105,105"
    metadata foregroundColor.editor	is "com.livecode.pi.color"
    metadata foregroundColor.label is "foregroundColor"

    metadata hiliteColor.default is "0,128,255"
    metadata hiliteColor.label is "Color"
    metadata hiliteColor.editor	is "com.livecode.pi.color"
    metadata hiliteColor.label is "hiliteColor"


    private variable mPatternPath as String
    property PatternPath get mPatternPath
    metadata PatternPath.default is ""
    metadata PatternPath.user_visible is "false"
    metadata PatternPath.label is "PatternPath"


    private variable mPatternError as Boolean
    metadata patternError.default is "false"
    metadata patternError.editor	is "com.livecode.pi.boolean"
    metadata patternError.user_visible is "false"
    metadata patternError.label is "PatternError"
    property patternError get mPatternError set setPatternError


    private handler setPatternError(in pValue as Boolean)
        variable tColor as Color

        if pValue is true then

            if mPatternPath is not "" then
                  variable tChar as String

                  repeat for each char tChar in mPatternPath
                      if tChar is "1" then
                        push 1 onto back of mNodePathList
                      else if tChar is "2" then
                        push 2 onto back of mNodePathList

                      else if tChar is "3" then
                        push 3 onto back of mNodePathList

                      else if tChar is "4" then
                        push 4 onto back of mNodePathList

                      else if tChar is "5" then
                        push 5 onto back of mNodePathList

                      else if tChar is "6" then
                        push 6 onto back of mNodePathList

                      else if tChar is "7" then
                        push 7 onto back of mNodePathList

                      else if tChar is "8" then
                        push 8 onto back of mNodePathList

                      else if tChar is "9" then
                        push 9 onto back of mNodePathList

                      end if
                  end repeat

                put true into mPatternError
                redraw all
            end if

          OnTimer()
        end if
    end handler

    --------------------------------------------------------------------------------

    public handler OnCreate()
        put 0 into mBackgroundOpacity
        put 0 into mCircleOver
        put 8 into mRoundRadius
        put true into mShowPattern
        put true into mShowNodesArea
        put false into mAnimated
        put 0 into mCurrentNode
        put 0 into mLastNode

        put false into mPatternError

        updateParameters()
    end handler


    public handler OnLoad(in pProperties as Array)
        if "backgroundOpacity" is among the keys of pProperties then
            put pProperties["backgroundOpacity"] into mBackgroundOpacity
        end if

        if "showPattern" is among the keys of pProperties then
            put pProperties["showPattern"] into mShowPattern
        end if

        if "roundRadius" is among the keys of pProperties then
            put pProperties["roundRadius"] into mRoundRadius
        end if

        if "showNodesArea" is among the keys of pProperties then
            put pProperties["showNodesArea"] into mShowNodesArea
        end if

        put false into mPatternError
        put false into mAnimated
        put 0 into mCircleOver
        put 0 into mCurrentNode
        put 0 into mLastNode
    end handler



    public handler OnSave(out rProperties as Array)
        put mBackgroundOpacity into rProperties["backgroundOpacity"]
        put mShowPattern into rProperties["showPattern"]
        put mRoundRadius into rProperties["roundRadius"]
        put mShowNodesArea into rProperties["showNodesArea"]

    end handler




    public handler updateParameters() returns nothing
        variable xC as Integer
        variable tRect as Rectangle
        variable tRectSize as Real
        variable tCounter as Integer

        put my height into mHeight
        put my width into mWidth
        put 1 into tCounter

        variable tExtraspace as Real

        if mHeight > mWidth then
            put (mHeight - mWidth)/2 into tExtraspace
            put rectangle [0, tExtraspace, mWidth, mHeight - tExtraspace] into mWorkRect

        else if mHeight < mWidth then
            put (mWidth - mHeight)/2 into tExtraspace
            put rectangle [tExtraspace, 0, mWidth - tExtraspace, mHeight] into mWorkRect

        else
            put rectangle [0, 0, mWidth, mHeight] into mWorkRect

        end if

        put (the width of mWorkRect)/3 into tRectSize

        put rectangle[the left of mWorkRect, the top of mWorkRect, the left of mWorkRect+tRectSize, the top of mWorkRect+tRectSize] into tRect
        put [] into mRectList
        put [] into mCirclePathList



        repeat with xC from 1 up to 9
          push tRect onto back of mRectList

          push circle path centered at point [(the left of tRect) + (the width of tRect)/2,(the top of tRect) + (the height of tRect)/2] with radius 25 onto back of mCirclePathList


          if tCounter is 3 then
            add tRectSize to the top of tRect
            set the left of tRect to the left of mWorkRect
            put 1 into tCounter

          else
            add tRectSize to the left of tRect
            add 1 to tCounter

          end if

        end repeat

        put "" into mPatternPath
        put false into mRecalculate
    end handler




    public handler OnGeometryChanged()
      if my width is not mWidth or my height is not mHeight then
        updateParameters()
      end if
    end handler



    public handler OnPaint()
        set the antialias of this canvas to true

        if mRecalculate then
          updateParameters()
        end if

        variable tElement as Path
        variable tIndex as Integer
        variable tRadius  as Integer

        set the paint of this canvas to my background paint
        set the opacity of this canvas to mBackgroundOpacity

        fill rounded rectangle path of mWorkRect with radius (mRoundRadius) on this canvas


        set the opacity of this canvas to 1

        repeat for each element tElement in  mCirclePathList
            put (the index of tElement in mCirclePathList) into tIndex
            put 5 into tRadius

            set the paint of this canvas to my foreground paint
            set the opacity of this canvas to 0.1

            if mShowNodesArea is false then
                set the opacity of this canvas to 0

            else if mCircleOver is tIndex then
                set the opacity of this canvas to 0.5

                if mPatternError is true then
                    set the paint of this canvas to solid paint with color [1,0.3,0.3]
                else
                    set the paint of this canvas to my highlight paint
                end if

                put tIndex into mLastNode
                put 6 into tRadius

            else if tIndex is in mNodePathList then
                if mPatternError is true then
                    set the paint of this canvas to solid paint with color [1,0.3,0.3]
                else
                    set the paint of this canvas to my highlight paint
                end if

            end if

            fill tElement on this canvas
            set the opacity of this canvas to 1

            fill circle path centered at rectCenter(the bounding box of tElement) with radius tRadius on this canvas
        end repeat


        ------------------Lines--------------------
      if mNodePathList is not [] and mShowPattern is true then
          set the stroke width of this canvas to 6
          if mPatternError is true then
              set the paint of this canvas to solid paint with color [1,0.3,0.3]
          else
              set the paint of this canvas to my highlight paint
          end if

          if the number of elements in mNodePathList > 1  then
            move to nodeNumbertoCenter(the first element of mNodePathList) on this canvas

            variable tCurrentNode as Integer
            /*
              put 0 into mCurrentNode
              put 0 into mLastNode
            */
            repeat with tCurrentNode from 2 up to the number of elements in mNodePathList

              line to nodeNumbertoCenter(element tCurrentNode of mNodePathList) on this canvas
            end repeat

        end if

        if mPatternError is false then
            move to nodeNumbertoCenter(the last element of mNodePathList) on this canvas
            line to (the mouse position) on this canvas
        end if
        stroke this canvas
      end if

        put false into mPatternError

    end handler


  private variable mMouseIsDown as Boolean

  public handler OnMouseDown()
    put true into mMouseIsDown
    put [] into mNodePathList
    put "" into mPatternPath
    put false into mPatternError

    OnMouseMove()
    post "mouseDown" to my script object with [the click button formatted as string]
  end handler


  public handler OnMouseUp()
    variable tString as String
    put false into mMouseIsDown

    if mNodePathList is not [] then
        post "validatePattern" to my script object with [ mPatternPath ]
    end if

    put [] into mNodePathList
    put 0 into mCircleOver
    redraw all

    if the mouse position is within my bounds then
			post "mouseUp" to my script object with [the click button formatted as string]
		else
			post "mouseRelease" to my script object with [the click button formatted as string]
		end if
  end handler


	public handler OnMouseCancel()
		post "mouseRelease" to my script object with [the click button formatted as string]
	end handler

  public handler OnMouseMove()
    variable tElement as Path
    variable tTNode as Integer
    variable tPosition as Point
    variable tColor as String

    put the mouse position into tPosition

    if mMouseIsDown then
        repeat for each element tElement in  mCirclePathList
          put (the index of tElement in mCirclePathList) into tTNode

          if (tPosition) is within the bounding box of tElement then
              if not (tTNode is in mNodePathList)  then
                  AdjustPath(tTNode)
                  push tTNode onto back of mNodePathList
                  put intToString(tTNode) after mPatternPath
                  put tTNode into mCircleOver
                  post "nodeEnter" to my script object with [ the click button ]
              end if

          else if tTNode is mCircleOver then
              put 0 into mCircleOver
              post "nodeLeave" to my script object with [ the click button ]

          end if
        end repeat

        redraw all

    end if
    post "mouseMove" to my script object with [the x of tPosition formatted as string,the y of tPosition formatted as string]
  end handler


public handler OnTimer()
  variable tHiliteColor as String

  if mPatternError is true then
    schedule timer in 0.5 seconds
  else
    put [] into mNodePathList
    put "" into mPatternPath
    redraw all
  end if
end handler


  private handler nodeNumbertoCenter(in pNodeNum as Integer) returns Point
    return rectCenter(element pNodeNum of mRectList)
  end handler


  private handler AdjustPath(in pNodeNum as Integer) returns nothing
      variable tLastNode as Integer

      if mNodePathList is [] then
        return nothing
      end if

      put the last element of mNodePathList into tLastNode

      if pNodeNum is 1 then
        if tLastNode is 3 and not(2 is in mNodePathList) then
          push 2 onto back of mNodePathList

        else if tLastNode is 9 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList

        else if tLastNode is 7 and not(4 is in mNodePathList) then
          push 4 onto back of mNodePathList

        end if

      else if pNodeNum is 2 then
        if tLastNode is 8 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList
        end if

      else if pNodeNum is 3 then
        if tLastNode is 1 and not(2 is in mNodePathList) then
          push 2 onto back of mNodePathList

        else if tLastNode is 9 and not(6 is in mNodePathList) then
          push 6 onto back of mNodePathList

        else if tLastNode is 7 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList

        end if

      else if pNodeNum is 4 then
        if tLastNode is 6 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList
        end if

      else if pNodeNum is 6 then
        if tLastNode is 4 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList
        end if

      else if pNodeNum is 7 then
        if tLastNode is 1 and not(4 is in mNodePathList) then
          push 4 onto back of mNodePathList

        else if tLastNode is 3 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList

        else if tLastNode is 9 and not(8 is in mNodePathList) then
          push 8 onto back of mNodePathList

        end if

      else if pNodeNum is 8 then
        if tLastNode is 2 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList
        end if

      else if pNodeNum is 9 then
        if tLastNode is 7 and not(8 is in mNodePathList) then
          push 8 onto back of mNodePathList

        else if tLastNode is 1 and not(5 is in mNodePathList) then
          push 5 onto back of mNodePathList

        else if tLastNode is 3 and not(6 is in mNodePathList) then
          push 6 onto back of mNodePathList

        end if
      end if
  end handler

-------------------------------------helpers-------------------------------------------

    public handler AdjustColorForEnabledState(in pColor as Color, in pEnabled as Boolean) returns Color
        if pEnabled then
            set the alpha of pColor to 1
        else
            set the alpha of pColor to 0.5
        end if

          return pColor
    end handler


    public handler colorToString(in pColor as Color, in pIncludeAlpha as Boolean) returns String
        variable tColor as String

        if pColor is nothing then
          return ""
        end if

        put FormatInt(the rounded of ((the red of pColor) * 255)) into tColor
        put "," & FormatInt(the rounded of ((the green of pColor) * 255)) after tColor
        put "," & FormatInt(the rounded of ((the blue of pColor) * 255)) after tColor

        if pIncludeAlpha then
          put "," & FormatInt(the rounded of ((the alpha of pColor) * 255)) after tColor
        end if

        return tColor
    end handler







    public handler FormatInt(in pNumber as Number) returns String
      variable tNumberString as String

      put pNumber formatted as string into tNumberString

      if "." is in tNumberString then
        variable tDotOffset
        put the first offset of "." in tNumberString into tDotOffset
        delete char tDotOffset to (the number of chars in tNumberString) of tNumberString
      end if

      return tNumberString
    end handler


    public handler rectCenter(in pRect as Rectangle) returns Point
        return point [the left of pRect + the width of pRect / 2, the top of pRect + the height of pRect / 2]
    end handler


    public handler resizeControlWidth(in pScriptObject as ScriptObject, in pIdealWidth as Number) returns nothing
        variable tLeft as String
        get property "topleft" of pScriptObject
        put the result into tLeft

        variable tList
        split tLeft by "," into tList
        put element 1 of tList into tLeft

        set property "width" of pScriptObject to the rounded of (pIdealWidth + 0.5)
        set property "left" of pScriptObject to tLeft
    end handler


    public handler resizeControlToRect(in pScriptObject as ScriptObject, in pRect as Rectangle, in pAlignToSide as String) returns nothing
          // We want to maintain the center left coordinate
          variable tSide as String
          variable tLoc as String
          variable tFixedLoc as String
          variable tList as List
          variable tProp as String

          -- Get current position
          if ["top left", "bottom left", "top right", "bottom right"] contains [pAlignToSide] then
            put pAlignToSide into tProp
            replace " " with "" in tProp
          else if ["left", "right"] contains [pAlignToSide] then
            put "top" & pAlignToSide into tProp
          else if pAlignToSide is "top" then
            put "topleft" into tProp
          else
            put "bottomleft" into tProp
          end if

          get property tProp of pScriptObject
          put the result into tSide
          split tSide by "," into tList

          -- Set dimensions
          set property "width" of pScriptObject to the rounded of (the width of pRect + 0.5)
          set property "height" of pScriptObject to the rounded of (the height of pRect + 0.5)

          -- Now reposition
          if ["top left", "bottom left", "top right", "bottom right"] contains [pAlignToSide] then
            set property tProp of pScriptObject to element 1 of tList & "," & element 2 of tList
          else

            if pAlignToSide is "left" or pAlignToSide is "right" then
              put element 1 of tList into tSide
            else
              put element 2 of tList into tSide
            end if

            get property "loc" of pScriptObject
            put the result into tLoc
            split tLoc by "," into tList

            if pAlignToSide is "left" or pAlignToSide is "right" then
              put element 2 of tList into tFixedLoc
            else
              put element 1 of tList into tFixedLoc
            end if

            set property pAlignToSide of pScriptObject to tSide

            -- now set y and maintain x
            get property "loc" of pScriptObject
            put the result into tLoc
            split tLoc by "," into tList
            if pAlignToSide is "left" or pAlignToSide is "right" then
              put element 1 of tList & "," & tFixedLoc into tLoc
            else
              put tFixedLoc & "," & element 2 of tList into tLoc
            end if

            -- set loc
            set property "loc" of pScriptObject to tLoc
          end if
    end handler




  public handler centerBoxWithinBox(inout xPathToCenter as Path, in pFocalPath as Path) returns nothing
      // 0 out
      translate xPathToCenter by [-the x of the bounding box of xPathToCenter, - the y of the bounding box of xPathToCenter]
      // Center
      translate xPathToCenter by [the right of the bounding box of pFocalPath - the width of the bounding box of pFocalPath/2 - the width of the bounding box of xPathToCenter/2, \
        the bottom of the bounding box of pFocalPath - the height of the bounding box of pFocalPath/2 - the height of the bounding box of xPathToCenter/2]
  end handler





end widget